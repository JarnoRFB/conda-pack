name: Build and test the package
on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master
jobs:
  package:
    runs-on: ubuntu-latest
    steps:
    - name: Retrieve the source code
      uses: actions/checkout@v2
      with:
        fetch-depth: 0
    - name: Install build dependencies
      run: |
        conda config --append channels conda-forge
        conda install -y conda-build conda-verify flake8 sphinx numpydoc sphinxcontrib-autoprogram make
        /usr/share/miniconda/bin/python -m pip install -e .
    - name: Verify flake8 compliance
      run: |
        source /usr/share/miniconda/bin/activate
        flake8 conda_pack
    - name: Build the docs as a test
      run: |
        source /usr/share/miniconda/bin/activate
        cd docs
        make html
    - name: Build the package
      run: conda build conda-recipe --no-test
    - name: Reduce the size of the build artifact
      run: rm -rf /usr/share/miniconda/conda-bld/{git_cache,work,conda-pack*,*/.cache}
    - name: Upload the build artifact
      uses: actions/upload-artifact@v2
      with:
        name: package-${{ github.sha }}
        path: /usr/share/miniconda/conda-bld
  testbed:
    defaults:
      run:
        shell: bash
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest,macos-latest,windows-latest]
    steps:
    - name: Retrieve the source code
      uses: actions/checkout@v2
    - id: cache
      name: Retrieve cache key
      uses: actions/cache@v2
      # By creating a super small cache that is keyed to the same hash
      # as the larger cache, we can exit this run much more quickly
      # if we have a cache hit. Any small file will do.
      with:
        path: ./LICENSE.txt
        key: key-${{ matrix.os }}-${{ hashFiles('conda-recipe') }}-5
    - id: cache
      if: steps.cache.outputs.cache-hit != 'true'
      name: Retrieve or create the conda cache
      uses: actions/cache@v2
      # In order to defeat the caching mechanism (for instance, to test
      # because you change this job), bump that final number in the key.
      with:
        path: conda
        key: testbed-${{ matrix.os }}-${{ hashFiles('testing') }}-2
    - name: Set CONDA_ROOT
      if: steps.cache.outputs.cache-hit != 'true'
      # Conda should be on the same filesystem as GITHUB_WORKSPACE. For Windows,
      # this disqualifies HOME. On the other hand, for macOS, GITHUB_WORKSPACE is
      # not the same from job to job for some reason. So the predictability of
      # HOME is a better choice. So two solutions are needed, unfortunately.
      run: |
        [ "$RUNNER_OS" == "Windows" ] && CONDA_ROOT="${GITHUB_WORKSPACE%\\*}\\conda"
        [ "$RUNNER_OS" != "Windows" ] && CONDA_ROOT="$HOME/conda"
        echo "::set-env name=CONDA_ROOT::${CONDA_ROOT}"
        echo "CONDA_ROOT: $CONDA_ROOT"
    - name: Create the root conda environment
      if: steps.cache.outputs.cache-hit != 'true'
      # We use the built-in conda to create our own independent conda
      # root. So we can fully control the contents of its package cache
      run: |
        [ "$RUNNER_OS" == "Windows" ] && CONDA_E="$CONDA/Scripts/conda.exe"
        [ "$RUNNER_OS" != "Windows" ] && CONDA_E=conda
        # We need to move the package cache to a writable location on the Mac
        # to work around an issue with GitHub's implementation. But we also
        # need to make sure to remove the workaround once our conda is in, so
        # that the cache is in $CONDA_PREFIX/pkgs where we expect it.
        $CONDA_E config --add pkgs_dirs ~/.pkgs
        $CONDA_E create -p $CONDA_ROOT conda
        $CONDA_E config --remove-key pkgs_dirs
    - name: Create the testbed
      if: steps.cache.outputs.cache-hit != 'true'
      # Build the environments for our conda-pack tests
      run: |
        source $CONDA_ROOT/etc/profile.d/conda.sh
        conda activate base
        export CONDA_PACK_TEST_ENVS=$CONDA_ROOT/envs
        bash testing/setup_envs.sh
    - name: Move the conda testbed into cache position
      if: steps.cache.outputs.cache-hit != 'true'
      # Move the conda installation into GITHUB_WORKSPACE to be cached.
      # Unfortunately actions/cache cannot yet be relied on to cache content
      # outside of GITHUB_WORKSPACE, so we have to jump through this hoop
      # here, and the reverse in the tests below.
      run: |
        rm -rf ./conda
        mv $CONDA_ROOT ./conda
  tests:
    defaults:
      run:
        shell: bash
    runs-on: ${{ matrix.os }}
    needs: [package,testbed]
    strategy:
      fail-fast: false
      matrix:
        os: [macos-latest,ubuntu-latest,windows-latest]
        pyver: [3.6,3.7,3.8,2.7]
    steps:
    - name: Retrieve the source code
      uses: actions/checkout@v2
    - name: Retrieve the conda cache
      uses: actions/cache@v2
      with:
        path: conda
        key: testbed-${{ matrix.os }}-${{ hashFiles('testing') }}
    - name: Set CONDA_ROOT
      run: |
        [ "$RUNNER_OS" == "Windows" ] && CONDA_ROOT="${GITHUB_WORKSPACE%\\*}\\conda"
        [ "$RUNNER_OS" != "Windows" ] && CONDA_ROOT="$HOME/conda"
        echo "::set-env name=CONDA_ROOT::${CONDA_ROOT}"
        echo "CONDA_ROOT: $CONDA_ROOT"
    - name: Move conda out of the cache and into position
      run: |
        mv ./conda $CONDA_ROOT
        ls -l $CONDA_ROOT
    - name: Download the build artifact
      uses: actions/download-artifact@v2
      with:
        name: package-${{ github.sha }}
        path: conda-bld
    - name: Move the build artifact into place
      run: |
        find conda-bld -print
        mv conda-bld $CONDA_ROOT
    - name: Create the test environment
      run: |
        source $CONDA_ROOT/etc/profile.d/conda.sh
        conda create -n cptest local::conda-pack pytest python=${{ matrix.pyver }}
        conda list -n cptest
    - name: Run the tests
      run: |
        source $CONDA_ROOT/etc/profile.d/conda.sh
        conda activate cptest
        export CONDA_PACK_TEST_ENVS=$CONDA_ROOT/envs
        pytest -v -ss conda_pack/tests
